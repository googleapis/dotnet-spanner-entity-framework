// Copyright 2025 Google LLC
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     https://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Google.Cloud.EntityFrameworkCore.Spanner.Extensions;
using Google.Cloud.EntityFrameworkCore.Spanner.Extensions.Internal;
using Google.Cloud.EntityFrameworkCore.Spanner.Infrastructure;
using Google.Cloud.EntityFrameworkCore.Spanner.Tests.AutoGeneratedPrimaryKeyTests.Model;
using Grpc.Core;
using Microsoft.EntityFrameworkCore;
using Xunit;
using V1 = Google.Cloud.Spanner.V1;

namespace Google.Cloud.EntityFrameworkCore.Spanner.Tests.AutoGeneratedPrimaryKeyTests;

public class AutoGeneratedPrimaryKeyMockServerTests : IClassFixture<SpannerMockServerFixture>
{
    internal class MockServerDbContext : AutoPrimaryKeyDbContext
    {
        private readonly string _connectionString;

        internal MockServerDbContext(string connectionString)
        {
            _connectionString = connectionString;
        }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (!optionsBuilder.IsConfigured)
            {
                optionsBuilder
                    .UseSpanner(_connectionString, _ => SpannerModelValidationConnectionProvider.Instance.EnableDatabaseModelValidation(false), ChannelCredentials.Insecure)
                    .UseLazyLoadingProxies();
            }
        }
    }
    
    private readonly SpannerMockServerFixture _fixture;

    public AutoGeneratedPrimaryKeyMockServerTests(SpannerMockServerFixture service)
    {
        _fixture = service;
        service.SpannerMock.Reset();
    }

    private string ConnectionString => $"Data Source=projects/p1/instances/i1/databases/d1;Host={_fixture.Host};Port={_fixture.Port}";

    [Fact]
    public async Task FindInvoiceAsync_ReturnsNull_IfNotFound()
    {
        var sql = $"SELECT `i`.`InvoiceId`, `i`.`Description`{Environment.NewLine}" +
                  $"FROM `Invoices` AS `i`{Environment.NewLine}" +
                  $"WHERE `i`.`InvoiceId` = @p{Environment.NewLine}" +
                  $"LIMIT 1";
        _fixture.SpannerMock.AddOrUpdateStatementResult(sql, StatementResult.CreateResultSet(
            new List<Tuple<V1.Type, string>>(),
            new List<object[]>()));

        await using var db = new MockServerDbContext(ConnectionString);
        var invoice = await db.Invoices.FindAsync(1L);
        Assert.Null(invoice);
    }

    [Fact]
    public async Task InsertInvoiceGeneratesAndReturnsPrimaryKey()
    {
        var sql = $"INSERT INTO `Invoices` (`Description`){Environment.NewLine}" +
                  $"VALUES (@p0){Environment.NewLine}" +
                  $"THEN RETURN `InvoiceId`{Environment.NewLine}";
        _fixture.SpannerMock.AddOrUpdateStatementResult(sql,
            StatementResult.CreateSingleColumnResultSet(1L, new V1.Type {Code = V1.TypeCode.Int64}, "InvoiceId", "12345"));

        await using var db = new MockServerDbContext(ConnectionString);
        var invoice = new Invoice
        {
            Description = "Test Invoice",
        };
        db.Invoices.Add(invoice);
        var updateCount = await db.SaveChangesAsync();
        Assert.Equal(1L, updateCount);
        Assert.Equal(12345L, invoice.InvoiceId);
    }

    [Fact]
    public async Task InsertInvoiceLineGeneratesAndReturnsPrimaryKey()
    {
        var insertInvoiceSql = $"INSERT INTO `Invoices` (`Description`){Environment.NewLine}" +
                  $"VALUES (@p0){Environment.NewLine}" +
                  $"THEN RETURN `InvoiceId`{Environment.NewLine}";
        _fixture.SpannerMock.AddOrUpdateStatementResult(insertInvoiceSql,
            StatementResult.CreateSingleColumnResultSet(1L, new V1.Type {Code = V1.TypeCode.Int64}, "InvoiceId", "12345"));
        var insertInvoiceLineSql =
            $"INSERT INTO `InvoiceLines` (`InvoiceId`, `Product`, `Quantity`){Environment.NewLine}" +
            $"VALUES (@p1, @p2, @p3){Environment.NewLine}" +
            $"THEN RETURN `InvoiceLineId`{Environment.NewLine}";
        _fixture.SpannerMock.AddOrUpdateStatementResult(insertInvoiceLineSql,
            StatementResult.CreateSingleColumnResultSet(1L, new V1.Type {Code = V1.TypeCode.Int64}, "InvoiceLineId", "54321"));

        await using var db = new MockServerDbContext(ConnectionString);
        var invoice = new Invoice
        {
            Description = "Test Invoice",
        };
        db.Invoices.Add(invoice);
        var line = new InvoiceLine
        {
            Invoice = invoice,
            Product = "Test product",
            Quantity = 100,
        };
        db.InvoiceLines.Add(line);
        var updateCount = await db.SaveChangesAsync();
        Assert.Equal(2L, updateCount);
        Assert.Equal(12345L, invoice.InvoiceId);
        Assert.Equal(12345L, line.InvoiceId);
        Assert.Equal(54321L, line.InvoiceLineId);
    }

}