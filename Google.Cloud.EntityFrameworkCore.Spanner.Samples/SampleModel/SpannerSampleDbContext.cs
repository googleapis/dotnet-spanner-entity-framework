// Copyright 2021 Google Inc. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using Google.Cloud.EntityFrameworkCore.Spanner.Extensions;
using Google.Cloud.EntityFrameworkCore.Spanner.Infrastructure;
using Google.Cloud.EntityFrameworkCore.Spanner.Metadata;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using System.Threading;
using System.Threading.Tasks;

namespace Google.Cloud.EntityFrameworkCore.Spanner.Samples.SampleModel
{
    /// <summary>
    /// Sample DatabaseContext that is used with all samples in this project.
    /// </summary>
    public partial class SpannerSampleDbContext : DbContext
    {
        private readonly string _connectionString;

        public SpannerSampleDbContext()
        {
            _connectionString = "DataSource=projects/my-project/instances/my-instance/database/my-database";
        }

        /// <summary>
        /// Creates a <see cref="DbContext"/> that connects to a Cloud Spanner database using the sample data model.
        /// </summary>
        /// <param name="connectionString">The connection string to use in the format 'DataSource=projects/my-project/instances/my-instance/database/my-database</param>
        public SpannerSampleDbContext(string connectionString)
        {
            _connectionString = connectionString;
        }

        /// <summary>
        /// Creates a <see cref="DbContext"/> that connects to a Cloud Spanner database using the sample data model.
        /// </summary>
        /// <param name="connectionString">The connection string to use in the format 'DataSource=projects/my-project/instances/my-instance/database/my-database</param>
        /// <param name="options">Additional options that are used to create the context.</param>
        public SpannerSampleDbContext(string connectionString, DbContextOptions<SpannerSampleDbContext> options)
            : base(options)
        {
            _connectionString = connectionString;
        }

        public virtual DbSet<Singer> Singers { get; set; }
        public virtual DbSet<Album> Albums { get; set; }
        public virtual DbSet<Track> Tracks { get; set; }
        public virtual DbSet<Venue> Venues { get; set; }
        public virtual DbSet<Concert> Concerts { get; set; }
        public virtual DbSet<Performance> Performances { get; set; }
        public virtual DbSet<TicketSale> TicketSales { get; set; }
        
        public virtual DbSet<Invoice> Invoices { get; set; }
        public virtual DbSet<InvoiceLine> InvoiceLines { get; set; }

        public void Log(string message)
        {
            Console.WriteLine(message);
        }

        protected override void OnConfiguring(DbContextOptionsBuilder options)
            // Configure Entity Framework to use a Cloud Spanner database.
            => options.LogTo(Log).UseSpanner(_connectionString).UseMutations(MutationUsage.Never);

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Singer>(entity =>
            {
                entity.HasKey(e => e.SingerId);
                entity.Property(e => e.Version).IsConcurrencyToken();

                // FullName is generated by Cloud Spanner on each add or update and should
                // not be included in the DML statements that are generated by Entity Framework.
                entity.Property(e => e.FullName).ValueGeneratedOnAddOrUpdate();
            });

            modelBuilder.Entity<Album>(entity =>
            {
                entity.HasKey(entity => new { entity.AlbumId });
                entity.Property(e => e.Version).IsConcurrencyToken();
            });

            modelBuilder.Entity<Track>(entity =>
            {
                entity
                    .InterleaveInParent(typeof(Album), OnDelete.Cascade)
                    .HasKey(entity => new { entity.AlbumId, entity.TrackId });
                entity.Property(e => e.TrackId)
                    .HasAnnotation(SpannerAnnotationNames.Identity, SpannerIdentityOptionsData.Default.Serialize())
                    .ValueGeneratedOnAdd();
                // Adding HasDefaultValueSql to the property makes sure that Entity Framework does
                // not include the column in an INSERT statement if the property does not have an
                // explicit value.
                entity.Property(e => e.RecordedAt).HasDefaultValueSql("CURRENT_TIMESTAMP");
                entity.Property(e => e.Version).IsConcurrencyToken();
            });

            modelBuilder.Entity<Venue>(entity =>
            {
                entity.HasKey(entity => new { entity.Code });
                entity.Property(e => e.Version).IsConcurrencyToken();
                entity.OwnsMany(e => e.Descriptions, builder =>
                {
                    builder.ToJson();
                });
            });

            modelBuilder.Entity<Concert>(entity =>
            {
                entity.HasKey(entity => new { entity.VenueCode, entity.StartTime, entity.SingerId });
                entity.Property(e => e.Version).IsConcurrencyToken();
            });

            modelBuilder.Entity<Performance>(entity =>
            {
                entity.HasKey(entity => new { entity.VenueCode, entity.StartTime, entity.SingerId });
                entity.Property(e => e.Version).IsConcurrencyToken();

                // Specify when the CreateAt and LastUpdatedAt columns should be updated.
                // You can also use SpannerUpdateCommitTimestamp.OnInsertAndUpdate to specify
                // that the commit timestamp should be updated both for inserts AND updates.
                // Note that these properties are NOT marked as generated with ValueGeneratedOnAddOrUpdate().
                entity.Property(e => e.CreatedAt)
                    .HasAnnotation(SpannerAnnotationNames.UpdateCommitTimestamp, SpannerUpdateCommitTimestamp.OnInsert);
                entity.Property(e => e.LastUpdatedAt)
                    .HasAnnotation(SpannerAnnotationNames.UpdateCommitTimestamp, SpannerUpdateCommitTimestamp.OnUpdate);

                // We need to specify the foreign keys of Performance because it has one column
                // that is included in two different foreign keys: SingerId is used to both
                // reference Singer (SingerId) and Concert (VenueCode, SingerId, StartTime).
                entity.HasOne(d => d.Singer)
                    .WithMany(p => p.Performances)
                    .HasForeignKey(d => d.SingerId)
                    .OnDelete(DeleteBehavior.ClientSetNull);

                entity.HasOne(d => d.Track)
                    .WithMany(p => p.Performances)
                    .HasForeignKey(d => new { d.AlbumId, d.TrackId })
                    .OnDelete(DeleteBehavior.ClientSetNull);

                entity.HasOne(d => d.Concert)
                    .WithMany(p => p.Performances)
                    .HasForeignKey(d => new { d.VenueCode, d.ConcertStartTime, d.SingerId })
                    .OnDelete(DeleteBehavior.ClientSetNull);
            });
            
            modelBuilder.Entity<TicketSale>(ticketSale =>
            {
                // Entity Framework automatically assumes that primary keys with type long
                // are auto-generated. It is therefore not necessary to specify that here.
                // Also, Entity Framework assumes that if the entity has a property named
                // 'Id', then that is the primary key of the entity.
                
                ticketSale.Property(e => e.Version).IsConcurrencyToken();

                ticketSale.HasOne(d => d.Concert)
                    .WithMany(p => p.TicketSales)
                    .HasForeignKey(d => new { d.VenueCode, d.ConcertStartTime, d.SingerId })
                    .OnDelete(DeleteBehavior.ClientSetNull);
            });
            
            modelBuilder.Entity<InvoiceLine>(entity =>
            {
                // Register both InvoiceId and InvoiceLineId as the primary key of the entity.
                entity.HasKey(e => new { e.InvoiceId, e.InvoiceLineId });
                // Tell Entity Framework that InvoiceLineId is generated when a new row is inserted.
                entity.Property(e => e.InvoiceLineId).ValueGeneratedOnAdd();
            });

            OnModelCreatingPartial(modelBuilder);
        }

        partial void OnModelCreatingPartial(ModelBuilder modelBuilder);

        public override int SaveChanges(bool acceptAllChangesOnSuccess)
        {
            // First update the versions of all entities that will be written to the database,
            // then send the modifications to the database.
            UpdateVersions();
            return base.SaveChanges(acceptAllChangesOnSuccess);
        }
        
        public override Task<int> SaveChangesAsync(
            bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default)
        {
            // First update the versions of all entities that will be written to the database,
            // then send the modifications to the database.
            UpdateVersions();
            return base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
        }
        
        /// <summary>
        /// Updates the versions of all entities that are currently marked as modified.
        /// </summary>
        internal void UpdateVersions()
        {
            var versionEntries = new ObservableHashSet<PropertyEntry>();
            foreach (EntityEntry entityEntry in ChangeTracker.Entries())
            {
                if (entityEntry.Entity is VersionedEntity versionedEntity)
                {
                    var propertyEntry = entityEntry.Property(nameof(versionedEntity.Version));
                    var currentVersion = (long)propertyEntry.CurrentValue;
                    propertyEntry.CurrentValue = currentVersion + 1L;
                    versionEntries.Add(propertyEntry);
                }
            }
            // Mark the updated versions as not being modified. This prevents the entity from being
            // included in any subsequent SaveChanges call, unless one of its actual properties is
            // updated.
            foreach (PropertyEntry pe in versionEntries)
            {
                pe.IsModified = false;
            }
        }
    }
}
